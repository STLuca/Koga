parser machineComposite;

structures {
    core.Char;
    core.Connection;
    core.Boolean;
    core.Pointer;
    core.Byte;
}

core.Int {

    ~ here is a comment
    Byte[4] val;

    constructor(b32 imm) {
        ~ Here is another comment
        ~ in fact what about two in a row
        i(ADD, II, P, val, I, 0d0, L, imm);
    }

    constructor(Int copy) {
        i(ADD, TI, P, val, P, copy.val, I, 0d0);
    }

    constructor(Char char) {
        i(ADD, TI, P, val, P, char.val, I, 0d0);
    }

    constructor port() {
        ~ Get the absolute address of val
        i(ADD, LI, P, val, R, task, P, val);
        Admin(PORT, val);
    }

    constructor task() {
        i(ADD, LI, P, val, R, task, I, 0d0);
    }

    constructor altTask() {
        i(ADD, LI, P, val, R, altTask, I, 0d0);
    }

    constructor altMethod() {
        i(ADD, LI, P, val, R, altInstruction, I, 0d0);
    }

    constructor currentObject() {
        i(ADD, LI, P, val, R, object, I, 0d0);
    }

    constructor currentTable() {
        i(ADD, LI, P, val, R, table, I, 0d0);
    }

    constructor pageOne(Connection connection) {
        i(ADD, TI, P, val, P, connection.pageOne, I, 0d0);
    }

    constructor pageTwo(Connection connection) {
        i(ADD, TI, P, val, P, connection.pageTwo, I, 0d0);
    }

    constructor instance(Connection connection) {
        i(ADD, TI, P, val, P, connection.instance, I, 0d0);
    }

    constructor pointerAddr(Pointer p) {
        i(ADD, TI, P, val, P, p.addr, I, 0d0);
    }

    set(b32 imm) {
        i(ADD, II, P, val, L, imm, I, 0d0);
    }

    plus(b32 imm) {
        i(ADD, TI, P, val, P, val, L, imm);
    }

    minus(b32 imm) {
        i(SUB, TI, P, val, P, val, L, imm);
    }

    plus(Int in) {
        i(ADD, TT, P, val, P, val, P, in.val);
    }

    plusInt(Int in) {
        i(ADD, TT, P, val, P, val, P, in.val);
    }

    plus(Byte b) {

    }

    multiply(b32 imm) {
        math(MULT, TI, P, val, P, val, L, imm);
    }

    greaterThan(b32 imm, Boolean dest) {
        i(SGT, TI, P, dest.val, P, val, L, imm);
    }

    lessThan(b32 imm, Int dest) {
        i(SLT, TI, P, dest.val, P, val, L, imm);
    }

    set(Int x) {
        i(ADD, TI, P, val, P, x.val, I, 0d0);
    }

    lessThan(b32 imm, Boolean dest) {
        i(SLT, TI, P, dest.val, P, val, L, imm);
    }

    equalTo(Int in, Boolean dest) {
        i(SEQ, TT, P, dest.val, P, val, P, in.val);
    }

    notEqualTo(Int in, Boolean dest) {
        i(SNEQ, TT, P, dest.val, P, val, P, in.val);
    }

    if(Int in, Block block) {
        Addr after;
        cb(NEQ, P, val, P, in.val, after);
        Block block;
        Addr after;
    }

    ifNot(Int in, Block block) {
        Addr after;
        cb(EQ, P, val, P, in.val, after);
        Block block;
        Addr after;
    }

    jumpPlusAddr(b32 imm) {
        j(REL, I, here);
        i(ADD, TI, P, val, P, val, L, imm);
        Addr here;
        i(ADD, TI, P, val, P, val, L, imm);
    }

    plusTwice(b32 imm) {
        Byte[4] tmpVal;
        i(ADD, TI, P, tmpVal, P, val, L, imm);
        i(ADD, TI, P, val, P, tmpVal, L, imm);
    }

    ~ Delete
    usingContext() {
        Context(IMPLICIT, int, P, val);
        Block super default {
            i(ADD, TT, P, val, L, int, L, int);
        };
    }

    ~ Delete
    makeBlock(Block b) {
        Block super {
            i(ADD, TI, P, val, L, int, I, 0d10);
        };
        Block b;
    }

}